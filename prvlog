#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Tool for updating and validating ProvenanceLogger (prvlog) files.

Usage:
  prvlog [options] PRVFILE
  prvlog -V 

Options:
    -c TARGFILE   Create PRVFILE log for target TARGFILE
    -u            Update PRVFILE, adding new MD5 checksum if it has changed
    -l MSG        Log a new MSG to the provenance chain in PRVFILE
    -f            Monitor current validity of FILE
    -V            Print version information
"""
import os        # for accessing local file system
import hashlib   # for generating MD5 hashes
import socket    # for accessing hostname of current machine
import datetime  # for adding date stamp to log records 
from docopt import docopt # for processing command line args

"""
prvlog <FILE>
    If FILE.prvlog already exists, validate its content before 
    continuing. Abort with explanation if not valid.

    Computes the MD5SUM of FILE and prepares to update FILE.prvlog.

    If FILE.prvlog already exists, compares computed MD5 to previous
    fingerprint recorded in FILE.prvlog. 
        If the checksum has changed, prompts the user for a note about why.
        If the checksum has not changed, informs users and terminates.

prvlog <FILE> -l 'MSG'
    Add a new comment record to FILE.prvlog, with checksum, and
    then recompute closing validation checksum

prvlog <FILE> -c OTHERFILE
    Create FILE.prvlog using OTHERFILE as MD5 checksum    

prvlog <FILE> -f
    Run the script in monitor mode, ending silently if the
    current MD5 matches the expected fingerprint, or reporting a
    problem to STDIO if one occurs.  This mode is used by 
    prvscan to produce its reports.

prvscan [ROOTDIR] [-r]
    Scan ROOTDIR for *.prvlog files.
    For each FILE.prvlog found, run `prvlog FILE -f` and 
    Defaults to current directory, non-recursive.
    relay any reported errors to STDIO.

    -r: scan recursively

It is up to the operator to add prvscan to a crontab if
continuous checking is needed.
"""

"""
28431f3f8ae3397d957f04150b1eff91  hostname://path/to/file/VIC_W2_Eth_ToP_5min_20210115.zip
@ 2021-01-20 11:22:17 Original file creation. 
< 2021-01-20 11:22:17 28431f3f8ae3397d957f04150b1eff91  hostname://path/to/file/VIC_W2_Eth_ToP_5min_20210115.zip
^80e0d410f20b970439a2e8133de7781f

Structure of a .PRVLOG file:
    Top line is always: MD5SUM  FNAME
        Represents most recent checksum of the subject file
        This top line was intentionally designed to reflect the
        common format of checksum files, so that pre-existing 
        checksums can be grandfathered into the PRV chain. 

        But a runtime warning will be issued by the prv system
        if that line does not contain a machine name and ://
        prefix. This is to give the operator a chance to update that
        entry with more complete information. In practice, however, this
        information is sometimes not available, so if it is not
        remediated, the historical information will be transfered as is to the
        comment section and the new top line will contain proper machine
        and prefix syntax. (Or possibly record it with the key value UNKNOWN for 
        machine name.)
                
    Followed by any number of comment entries.

    Comment consists of an @ line and a < line.

    @ Is a timestamped comment regarding a provenance/integrity change.

    < Is a timestamped snapshot of the checksum and file path taken from 
      top line of this file prior to adding this comment.

    Last line of the file is the ^ line, which is just the checksum of all the lines of this file, prior to this line.

    Any operation on this file will fail with a warning message
    if the ^ line does not match the previous content.

So every distinct variant in the lineage of FILE is documented in
the PRV file, including its checksum value and its fully
normalized storage path and name. (Which will help us locate
backups of that file on those previous machines, if nec.)

In addition, this file also serves as its own checksum record.

PRV Scanning:
    On a PRV-enabled computer, a service runs on a regular schedule,
    searching for .prv files and verifying that the active checksum
    value for its subject file is still valid, and that the
    self-checksum at the end is also still valid.

    If the subject file checksum is ever found to be incorrect, the
    operator is notified. 

    If the mismatch is caused by an accidental alteration, the file
    can be restored and no changes are required to the PRV file. But
    if the alteration was intentional, then the operator issues
    another prv change, which updates the PRV file, along with an
    explanation of the change.

    For data stored in non-atomic form, such as tables in a DB, there
    is no simple way to run a PRV-scan. Instead, a regularly scheduled 
    pre-prv script can be run to generate a DB-fingerprint file of the 
    table, which can then be tracked within the PRV system.

    (Alternatively, the table could be intuited from the path and
recomputed at verification time, but that would require the PRV
system to have an extensible scripting system to let it probe
paths on different DBs and protocols. It's simpler to leave that
to the operator to set up in an independent cron job.)


For files that can be accommodated within git, some of these
features are redundant. After all, git can tell you when a file
has been changed. Unfortunately, git does not play nicely with
enormous datasets, cannot provide much information about the
nature of a change to binary content, and does not have access to
provenance history before it was first moved into git control on 
this machine.

prv log PRVFILE
prv log -c CHKSUMFILE PRVFILE
prv verify PRVFILE
"""

def verify_prvlog_contents(filepath):
    """
    Given a filehandle to a prvlog file, parse the contents and verify its fingerprint.
    Returns True if file is validated.
    Prints warning and returns False if file is not validated.
    """
    with open(filepath, 'r') as fh:
        content = ''
        for line in fh.readlines():
            if line[0] == '^': # is this the validation fingerprint?
                saved_fingerprint = line[1:].strip()
                computed_fingerprint = hashlib.md5(content.encode('utf-8')).hexdigest()
                # print(f"Saved: {saved_fingerprint}")
                # print(f"Calcd: {computed_fingerprint}")
                if saved_fingerprint == computed_fingerprint:
                    return True
                else:
                    print("Calculated fingerprint does not match expected fingerprint.")
                    print(f"{saved_fingerprint} != {computed_fingerprint}")
                    return False
            content += line
        print("No integrity fingerprint found. File is not valid.")
        return False


def verify_target_file(filepath, expected_fingerprint):
    """
    Given a filehandle to a target file and a known fingerprint,
    compute a fingerprint for the content of the target and ensure  
    that it matches the expected.
    Returns True if file is validated.
    Returns False if file is not validated.
    """
    calculated_fingerprint = compute_fingerprint(filepath)
    return calculated_fingerprint and (calculated_fingerprint == expected_fingerprint)

def compute_fingerprint(targfile):
    """
    Given a path to a file, compute the MD5 checksum of that
    target, and do so in a manner that is efficient for large
    files. Returns the hexdigest string of the computed checksum.
    """
    blk_size_to_read = 65536
    filehash = hashlib.md5()
    with open(targfile, 'rb') as f:
        while (True):
            read_data = f.read(blk_size_to_read)
            if not read_data:
                break
            filehash.update(read_data)
        fing = filehash.hexdigest()
        return fing
    return None


def save_prvlog_file(content, prvfile):
    """
    Given some content and a filepath, save the content to the
    filepath and append a content checksum.
    """
    computed_fingerprint = hashlib.md5(content.encode('utf-8')).hexdigest()
    with open(prvfile, 'w') as fh:
        fh.write(content)
        fh.write(f"^{computed_fingerprint}\n")


def prompt_for_log_entry(prompt=''):
    """
    Ask the user to provide a string describing the current
    version of the target file.  
    Returns the provided string in the form of a PRVFILE comment
    entry.
    """
    if not prompt:
        prompt = "Describe changes made to the target file: "
    desc = input(prompt.strip() + ' ')
    return desc


def unpack_log_file(fpath):
    """
    Given a path to a prvlog file, unpack it and return
    headline, comments, validationline
    """
    lines = []
    with open(fpath, 'r') as fh:
        for line in fh.readlines():
            if line.strip():
                lines.append(line)
    headline = lines[0]
    content = lines[1:-1]
    validationline = lines[-1]
    return (headline, content, validationline)


def unpack_uri(targetpath):
    """
    Given a uri of the form machine://path, split it up and
    return machinename, abspath
    """
    if not ':' in targetpath:
        print("Malformed target path.")
        return None, None
    machine,dum,fileuri = targetpath.partition(':')
    if not fileuri.startswith('///'):
        print("Malformed target path.")
        return None, None
    abspath = fileuri[2:].strip() #remove trailing newline
    return machine,abspath


if __name__ == "__main__":
    args = docopt(__doc__, version='0.1.1')

    prvfile = args['PRVFILE']
    if os.path.isfile(prvfile):
        if verify_prvlog_contents(prvfile):
            print("Log file is internally consistent.")
        else:
            exit(1)
    else:
        print(f"Log file '{prvfile}' does not exist")

    current_machine = socket.gethostname()

    if args['-c']:
        targfile = args['-c']
        if os.path.isfile(prvfile):
            print(f"Log file '{prvfile}' already exists. Cannot proceed.")
            exit()
        print(f"Creating new log file in {prvfile}.")
        # assemble the header row info
        fingerprint = compute_fingerprint(targfile)
        uri = f"{current_machine}://{os.path.abspath(targfile)}"
        headline = f"{fingerprint}  {uri}\n"

        # assemble the log comment for this first version
        datestr = datetime.date.today().strftime("%Y-%m-%d %H:%M:%D")
        origin = prompt_for_log_entry("Describe origin of the target file: ")
        logline = f"@ {datestr} {origin}\n"
        logstamp = f"< {datestr} {headline}\n"

        content = f"{headline}{logline}{logstamp}"
        save_prvlog_file(content, prvfile)
        print("Log file created.")
        exit()

    if args['-u']:
        # -u            Update PRVFILE, adding new MD5 checksum if it has changed
        # read old content
        # extract headline
        # compute new headline
        # query user for new comment
        # assemble new content
        # compute validation fingerprint for new content
        # write new version of file
        pass

    if args['-l']:
        # -l MSG        Log a new MSG to the provenance chain in PRVFILE
        # read old content
        # extract headline
        # query user for new comment
        # assemble new content
        # compute validation fingerprint for new content
        # write new version of file
        pass

    if args['-f']:
        # -f            Monitor current validity of FILE
        # read old content
        headline,content,validationline = unpack_log_file(prvfile)
        # extract fingerprint and target path from headline
        [expected_fingerprint, targetpath] = headline.split()
        # verify machine name
        machine,abspath = unpack_uri(targetpath)
        if not os.path.isfile(abspath):
            print(f"Target file '{abspath}' does not exist.")
            exit(2)
        print(f"Target file exists.")
        if machine != current_machine:
            print(f"Target file {abspath} has moved to host {current_machine} from {machine}")
            exit(3)
        print("Machine names match.")
        if not verify_target_file(abspath, expected_fingerprint):
            print("{targetpath} does not match current fingerprint recorded in {prvfile}")
            exit(4)
        print("Fingerprints match.")
        exit(0)
